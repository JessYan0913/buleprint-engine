{"remainingRequest":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/babel-loader/lib/index.js!/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/yanheng/Documents/work/web/terino-drawing-engine/src/components/ThreeView.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/src/components/ThreeView.vue","mtime":1617110191483},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.array.sort\";\nimport _toConsumableArray from \"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es7.object.entries\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _defineProperty from \"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.function.name\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/**\n * 二维坐标系以左上角为原点\n * 三维坐标系以俯视图左上角为原点，Z轴指向屏幕外\n * width：俯视图中的宽（X轴）\n * height：俯视图中的高（Y轴）\n * depth：正视图中的高（Z轴）\n */\nimport Vue from \"vue\";\nimport parts from \"@/mock/parts.json\";\nimport MarkerView from \"@/components/MarkerView\";\nimport VueHtml2pdf from \"vue-html2pdf\";\nimport _ from \"lodash\";\nvar Perspective = {\n  Front: \"front\",\n  Side: \"side\",\n  Overlook: \"overlook\"\n};\nvar PartType = {\n  Beam: \"beam\",\n  Runway: \"runway\",\n  Structure: \"structure\"\n};\nvar PADDING = 60;\nvar WIDTH_SCALE = 50;\nvar HEIGHT_SCALE = 100;\nvar MIN_PERSPECTIVE_SIZE = [1200, 1000];\nVue.prototype.Perspective = Perspective;\nVue.prototype.PartType = PartType;\nexport default {\n  name: \"ThreeView\",\n  components: {\n    MarkerView: MarkerView,\n    VueHtml2pdf: VueHtml2pdf\n  },\n  data: function data() {\n    return {\n      realWidth: 20000,\n      perspectives: [{\n        name: Perspective.Overlook,\n        parts: [],\n        markers: [],\n        rects: []\n      }, {\n        name: Perspective.Front,\n        parts: [],\n        markers: [],\n        rects: []\n      }, {\n        name: Perspective.Side,\n        parts: [],\n        markers: [],\n        rects: []\n      }],\n      typedParts: {}\n    };\n  },\n  created: function created() {\n    this.typedParts = parts ? parts.reduce(function (pre, item) {\n      pre[item.type] = item;\n      return pre;\n    }, {}) : {};\n  },\n  mounted: function mounted() {\n    this.reload();\n  },\n  computed: {\n    beam: function beam() {\n      return this.typedParts[PartType.Beam] || {};\n    },\n    runway: function runway() {\n      return this.typedParts[PartType.Runway] || {};\n    },\n    structure: function structure() {\n      return this.typedParts[PartType.Structure] || {};\n    },\n    scale: function scale() {\n      return Math.min(this.widthScale, this.heightScale, 1);\n    },\n    widthScale: function widthScale() {\n      var _this = this;\n\n      return this.perspectives.reduce(function (pre, item) {\n        return Math.min((_this.perspectiveWidth - PADDING * 2) / _this.getRequiredRealWidth(item.name), pre);\n      }, 1);\n    },\n    heightScale: function heightScale() {\n      var _this2 = this;\n\n      return this.perspectives.reduce(function (pre, item) {\n        return Math.min((_this2.perspectiveHeight - PADDING * 2) / _this2.getRequiredRealHeight(item.name), pre);\n      }, 1);\n    },\n    numberOfRunways: function numberOfRunways() {\n      return Math.ceil(this.realWidth / this.runway.realWidth);\n    },\n    numberOfStructures: function numberOfStructures() {\n      return Math.ceil(this.realWidth / this.structure.realSpan) + 1;\n    },\n    numberOfBeams: function numberOfBeams() {\n      return 1;\n    },\n    zoom: function zoom() {\n      return MIN_PERSPECTIVE_SIZE[0] / this.perspectiveWidth;\n    },\n    perspectiveWidth: function perspectiveWidth() {\n      return Math.max(this.realWidth / WIDTH_SCALE, MIN_PERSPECTIVE_SIZE[0]);\n    },\n    perspectiveHeight: function perspectiveHeight() {\n      return Math.max(this.realWidth / HEIGHT_SCALE, MIN_PERSPECTIVE_SIZE[1]);\n    }\n  },\n  methods: {\n    reload: function reload() {\n      var _this3 = this;\n\n      var _iterator = _createForOfIteratorHelper(this.perspectives),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var perspective = _step.value;\n          perspective.style = {\n            position: \"relative\",\n            width: _this3.perspectiveWidth * _this3.zoom + \"px\",\n            height: _this3.perspectiveHeight * _this3.zoom + \"px\",\n            transform: \"scale(\".concat(_this3.zoom, \")\"),\n            transformOrigin: \"0 0\"\n          };\n          perspective.parts = [];\n          perspective.markers = [];\n          perspective.rects = [];\n          var pname = perspective.name;\n          var needMarkerParts = [];\n          var lastPart = void 0;\n\n          for (var i = 0; i < _this3.numberOfStructures; i++) {\n            var part = _objectSpread({\n              id: _.uniqueId(\"part-\")\n            }, _this3.structure);\n\n            _this3.applyStyleToPart(part, pname, i);\n\n            _this3.appendPartRect(part, pname);\n\n            perspective.parts.push(part);\n\n            if (i === 0) {\n              needMarkerParts.push(part);\n            }\n\n            if (i > 0 && pname === Perspective.Overlook) {\n              var number = (_this3.realWidth - part.realWidth) / (_this3.numberOfStructures - 1);\n              number = parseInt(number);\n              var mainAxisStart = parseFloat(lastPart.style.top);\n              var mainAxisEnd = parseFloat(lastPart.style.top) + parseFloat(lastPart.style.height);\n              var subAxisStart = parseFloat(lastPart.style.left) + parseFloat(lastPart.style.width) / 2;\n              var subAxisEnd = parseFloat(part.style.left) + parseFloat(part.style.width) / 2 + 1;\n\n              var marker = _this3.generateMarker(pname, number, false, mainAxisStart, mainAxisEnd, subAxisStart, subAxisEnd);\n\n              if (marker) {\n                perspective.markers.push(marker);\n              }\n            }\n\n            lastPart = part;\n          }\n\n          if (!_this3.structure.joints) {\n            return \"continue\";\n          }\n\n          var hasAppendRunwayMarker = false;\n          var hasAppendBeamMarker = false;\n\n          var _iterator2 = _createForOfIteratorHelper(_this3.structure.joints),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var joint = _step2.value;\n\n              if (joint.type === PartType.Runway) {\n                for (var _i = 0; _i < _this3.numberOfRunways; _i++) {\n                  var _part = _objectSpread({\n                    id: _.uniqueId(\"part-\")\n                  }, _this3.runway);\n\n                  _this3.applyStyleToPart(_part, pname, _i);\n\n                  _this3.applyJointStyleToPart(_part, joint, pname);\n\n                  _this3.appendPartRect(_part, pname);\n\n                  perspective.parts.push(_part);\n\n                  if (!hasAppendRunwayMarker && _i == _this3.numberOfRunways - 1) {\n                    hasAppendRunwayMarker = true;\n                    needMarkerParts.push(_part);\n                  }\n                }\n              }\n\n              if (joint.type === PartType.Beam) {\n                for (var _i2 = 0; _i2 < _this3.numberOfBeams; _i2++) {\n                  var _part2 = _objectSpread({\n                    id: _.uniqueId(\"part-\")\n                  }, _this3.beam);\n\n                  _this3.applyStyleToPart(_part2, pname, _i2);\n\n                  _this3.applyJointStyleToPart(_part2, joint, pname);\n\n                  _this3.appendPartRect(_part2, pname);\n\n                  perspective.parts.push(_part2);\n\n                  if (!hasAppendBeamMarker && _i2 == _this3.numberOfBeams - 1) {\n                    hasAppendBeamMarker = true;\n                    needMarkerParts.push(_part2);\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          needMarkerParts.forEach(function (item) {\n            return _this3.renderPartMarkers(pname, item);\n          });\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _ret = _loop();\n\n          if (_ret === \"continue\") continue;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    },\n    getMarkerTextWidth: function getMarkerTextWidth(text) {\n      var element = document.createElement(\"canvas\");\n      var context = element.getContext(\"2d\");\n      context.font = \"12px Arial\";\n      return context.measureText(text).width;\n    },\n    renderPartMarkers: function renderPartMarkers(pname, part) {\n      var _this4 = this;\n\n      var perspective = this.getPerspective(pname);\n      var markerOptions = this.getMarkerOptions(part, pname);\n      Object.entries(markerOptions).forEach(function (item) {\n        var _iterator3 = _createForOfIteratorHelper(item[1]),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var option = _step3.value;\n            var xAxis = item[0] === \"y\";\n            var _part$style = part.style,\n                top = _part$style.top,\n                left = _part$style.left,\n                width = _part$style.width,\n                height = _part$style.height;\n            var range = option.range,\n                mainAxisInsets = option.mainAxisInsets;\n\n            if (!_this4.isValidArray(range, 2)) {\n              continue;\n            }\n\n            var number = range[1] - range[0];\n            var mainAxisStart = void 0,\n                mainAxisEnd = void 0,\n                subAxisStart = void 0;\n\n            if (xAxis) {\n              mainAxisStart = parseFloat(left);\n              mainAxisEnd = parseFloat(left) + parseFloat(width);\n              subAxisStart = parseFloat(top) + range[0] * _this4.scale;\n            } else {\n              mainAxisStart = parseFloat(top);\n              mainAxisEnd = parseFloat(top) + parseFloat(height);\n              subAxisStart = parseFloat(left) + range[0] * _this4.scale;\n            }\n\n            var marker = _this4.generateMarker(pname, number, xAxis, mainAxisStart, mainAxisEnd, subAxisStart, null, mainAxisInsets.ahead, mainAxisInsets.behind);\n\n            if (!marker) {\n              continue;\n            }\n\n            perspective.markers.push(marker);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      });\n    },\n    appendPartRect: function appendPartRect(part, pname) {\n      var style = part.style;\n      var perspective = this.getPerspective(pname);\n      perspective.rects.push({\n        top: parseFloat(style.top),\n        left: parseFloat(style.left),\n        right: parseFloat(style.left) + parseFloat(style.width),\n        bottom: parseFloat(style.top) + parseFloat(style.height)\n      });\n    },\n    isRectOverlap: function isRectOverlap(rect1, rect2) {\n      return !(rect1.right <= rect2.left || rect1.left >= rect2.right || rect1.bottom <= rect2.top || rect1.top >= rect2.bottom);\n    },\n    generateMarker: function generateMarker(pname, number, xAxis, mainAxisStart, mainAxisEnd, subAxisStart, subAxisEnd, aheadInsets, behindInsets) {\n      if (!aheadInsets) {\n        aheadInsets = [0, 0];\n      }\n\n      if (!behindInsets) {\n        behindInsets = [0, 0];\n      }\n\n      var isValidInsets = this.isValidArray(aheadInsets, 2) && this.isValidArray(behindInsets, 2);\n\n      if (!isValidInsets) {\n        return null;\n      }\n\n      var perspective = this.getPerspective(pname);\n      var style = {};\n      var scale = this.scale;\n      aheadInsets = aheadInsets.map(function (item) {\n        return item * scale;\n      });\n      behindInsets = behindInsets.map(function (item) {\n        return item * scale;\n      });\n      var maxAheadInset = Math.max.apply(Math, _toConsumableArray(aheadInsets));\n      var maxBehindInset = Math.max.apply(Math, _toConsumableArray(behindInsets));\n      var insets;\n\n      var sortedRects = _toConsumableArray(perspective.rects);\n\n      sortedRects.sort(function (item1, item2) {\n        if (xAxis) {\n          return item1.left > item2.left ? 1 : -1;\n        }\n\n        return item1.top > item2.top ? 1 : -1;\n      });\n      var mainAxisMinWidth = 20;\n      var subAxisMinArrowWidth = 20;\n      var subAxisAvailableWidth = subAxisEnd ? subAxisEnd - subAxisStart : number * scale;\n      var textWidth = this.getMarkerTextWidth(number);\n      var textHeight = 20;\n      var isNarrow = false;\n      var fixedSize = 0;\n\n      var polyfillRect = _objectSpread({}, sortedRects[0]);\n\n      if (xAxis) {\n        polyfillRect.right = polyfillRect.left;\n        polyfillRect.left -= Math.max(mainAxisMinWidth, textWidth + 5);\n      } else {\n        polyfillRect.bottom = polyfillRect.top;\n        polyfillRect.top -= mainAxisMinWidth;\n      }\n\n      sortedRects.unshift(polyfillRect);\n\n      if (xAxis) {\n        isNarrow = subAxisAvailableWidth < subAxisMinArrowWidth * 2 + textHeight;\n\n        if (isNarrow) {\n          fixedSize = subAxisAvailableWidth + subAxisMinArrowWidth * 2 + textHeight;\n        } else {\n          fixedSize = subAxisAvailableWidth;\n        }\n      } else {\n        isNarrow = subAxisAvailableWidth < subAxisMinArrowWidth * 2 + textWidth;\n\n        if (isNarrow) {\n          fixedSize = subAxisAvailableWidth + textWidth + subAxisMinArrowWidth * 2;\n        } else {\n          fixedSize = subAxisAvailableWidth;\n        }\n      }\n\n      var narrowOffset = 0;\n\n      if (isNarrow) {\n        narrowOffset = xAxis ? subAxisMinArrowWidth + textHeight : subAxisMinArrowWidth + textWidth;\n      }\n\n      var rect;\n      var textRect;\n      var arrowRect1;\n      var arrowRect2;\n      var hasNarrowSpacingAhead = true;\n      var arrowWidth = 6;\n      var arrowHeight = 8;\n\n      for (var i = 0; i < 2; i++) {\n        rect = null;\n        textRect = null;\n        arrowRect1 = null;\n        arrowRect2 = null;\n        var minTop = void 0,\n            minLeft = void 0,\n            maxBottom = 0,\n            maxRight = 0;\n        var hasAvailableRect = false;\n\n        for (var j = 0; j < sortedRects.length; j++) {\n          var sortedRect = sortedRects[j];\n\n          if (!minTop) {\n            minTop = sortedRect.top;\n          } else {\n            minTop = Math.min(sortedRect.top, minTop);\n          }\n\n          if (!minLeft) {\n            minLeft = sortedRect.left;\n          } else {\n            minLeft = Math.min(sortedRect.left, minLeft);\n          }\n\n          maxRight = Math.max(sortedRect.right, maxRight);\n          maxBottom = Math.max(sortedRect.bottom, maxBottom);\n          var isOverlap = !textRect || this.isRectOverlap(textRect, sortedRect) || this.isRectOverlap(arrowRect1, sortedRect) || this.isRectOverlap(arrowRect2, sortedRect);\n\n          if (isOverlap) {\n            var textSpacing = 5;\n\n            if (xAxis) {\n              var isAhead = sortedRect.right + mainAxisMinWidth <= mainAxisStart;\n              rect = {\n                top: subAxisStart - narrowOffset,\n                left: isAhead ? sortedRect.right : mainAxisEnd,\n                bottom: subAxisStart - narrowOffset + fixedSize,\n                right: isAhead ? mainAxisStart : Math.max(sortedRect.right, mainAxisEnd) + mainAxisMinWidth\n              };\n              textRect = {\n                left: (isAhead ? rect.left : rect.right - mainAxisMinWidth) - (textWidth - mainAxisMinWidth) / 2,\n                right: (isAhead ? rect.left + mainAxisMinWidth : rect.right) + (textWidth - mainAxisMinWidth) / 2\n              };\n              var arrowLeft = (isAhead ? rect.left + mainAxisMinWidth / 2 : rect.right - mainAxisMinWidth / 2) - arrowWidth / 2;\n              var arrowRight = arrowLeft + arrowWidth;\n              arrowRect1 = {\n                left: arrowLeft,\n                right: arrowRight\n              };\n              arrowRect2 = _objectSpread({}, arrowRect1);\n\n              if (isNarrow) {\n                textRect.top = hasNarrowSpacingAhead ? rect.top : rect.bottom - textHeight;\n                textRect.bottom = hasNarrowSpacingAhead ? rect.top + textHeight : rect.bottom;\n                arrowRect1.top = rect.top + (hasNarrowSpacingAhead ? textHeight : 0);\n                arrowRect1.bottom = arrowRect1.top + subAxisMinArrowWidth;\n                arrowRect2.top = rect.bottom - subAxisMinArrowWidth - (hasNarrowSpacingAhead ? 0 : textHeight);\n                arrowRect2.bottom = arrowRect2.top + subAxisMinArrowWidth;\n              } else {\n                textRect.top = (rect.bottom + rect.top - textHeight) / 2;\n                textRect.bottom = textRect.top + textHeight;\n                arrowRect1.top = rect.top;\n                arrowRect1.bottom = arrowRect1.top + arrowHeight;\n                arrowRect2.top = rect.bottom - arrowHeight;\n                arrowRect2.bottom = rect.bottom;\n              }\n            } else {\n              var _isAhead = sortedRect.bottom + mainAxisMinWidth <= mainAxisStart;\n\n              rect = {\n                top: _isAhead ? sortedRect.bottom : mainAxisEnd,\n                left: subAxisStart - narrowOffset,\n                bottom: _isAhead ? mainAxisStart : Math.max(sortedRect.bottom, mainAxisEnd) + mainAxisMinWidth,\n                right: subAxisStart - narrowOffset + fixedSize\n              };\n              textRect = {\n                top: _isAhead ? rect.top : rect.bottom - mainAxisMinWidth,\n                bottom: _isAhead ? rect.top + mainAxisMinWidth : rect.bottom\n              };\n              var arrowTop = (_isAhead ? rect.top + mainAxisMinWidth / 2 : rect.bottom - mainAxisMinWidth / 2) - arrowWidth / 2;\n              var arrowBottom = arrowTop + arrowWidth;\n              arrowRect1 = {\n                top: arrowTop,\n                bottom: arrowBottom\n              };\n              arrowRect2 = _objectSpread({}, arrowRect1);\n\n              if (isNarrow) {\n                textRect.left = hasNarrowSpacingAhead ? rect.left : rect.right - textWidth;\n                textRect.right = hasNarrowSpacingAhead ? rect.left + textWidth : rect.right;\n                arrowRect1.left = rect.left + (hasNarrowSpacingAhead ? textWidth : 0);\n                arrowRect1.right = arrowRect1.left + subAxisMinArrowWidth;\n                arrowRect2.left = rect.right - subAxisMinArrowWidth - (hasNarrowSpacingAhead ? 0 : textWidth);\n                arrowRect2.right = arrowRect2.left + subAxisMinArrowWidth;\n              } else {\n                textRect.left = (rect.right + rect.left - textWidth) / 2;\n                textRect.right = textRect.left + textWidth;\n                arrowRect1.left = rect.left;\n                arrowRect1.right = arrowRect1.left + arrowWidth;\n                arrowRect2.left = rect.right - arrowWidth;\n                arrowRect2.right = rect.right;\n              }\n            }\n\n            textRect.left -= textSpacing;\n            textRect.right += textSpacing;\n          } else if (j === sortedRects.length - 1) {\n            hasAvailableRect = true;\n          }\n        }\n\n        if (!hasAvailableRect && isNarrow && i === 0) {\n          narrowOffset = subAxisMinArrowWidth;\n          hasNarrowSpacingAhead = false;\n          continue;\n        }\n\n        var aheadDistance = void 0,\n            behindDistance = void 0,\n            rectDistance = Infinity;\n        var epsilon = 1;\n\n        if (xAxis) {\n          aheadDistance = Math.abs(minLeft - mainAxisStart);\n          behindDistance = Math.abs(maxRight - mainAxisEnd);\n\n          if (hasAvailableRect) {\n            rectDistance = rect.left < mainAxisStart ? mainAxisStart - rect.left : rect.right - mainAxisEnd;\n          }\n\n          var minDistance = Math.min(aheadDistance, behindDistance, rectDistance);\n\n          if (Math.abs(minDistance - rectDistance) <= epsilon) {\n            break;\n          }\n\n          if (minDistance === aheadDistance) {\n            rect.left = minLeft;\n            rect.right = mainAxisStart;\n          } else if (minDistance === behindDistance) {\n            rect.left = mainAxisEnd;\n            rect.right = maxRight + mainAxisMinWidth;\n          }\n        } else {\n          aheadDistance = Math.abs(minTop - mainAxisStart);\n          behindDistance = Math.abs(maxBottom - mainAxisEnd);\n\n          if (hasAvailableRect) {\n            rectDistance = rect.top < mainAxisStart ? mainAxisStart - rect.top : rect.bottom - mainAxisEnd;\n          }\n\n          var _minDistance = Math.min(aheadDistance, behindDistance, rectDistance);\n\n          if (Math.abs(_minDistance - rectDistance) <= epsilon) {\n            break;\n          }\n\n          if (_minDistance === aheadDistance) {\n            rect.top = minTop;\n            rect.bottom = mainAxisStart;\n          } else if (_minDistance === behindDistance) {\n            rect.top = mainAxisEnd;\n            rect.bottom = maxBottom + mainAxisMinWidth;\n          }\n        }\n\n        break;\n      }\n\n      var clazz;\n\n      if (xAxis) {\n        var _isAhead2 = rect.left + mainAxisMinWidth <= mainAxisStart;\n\n        insets = _isAhead2 ? aheadInsets : behindInsets;\n        style.top = subAxisStart + \"px\";\n        style.left = rect.left - (_isAhead2 ? 0 : maxBehindInset) + \"px\";\n        style.height = subAxisAvailableWidth + \"px\";\n        style.width = rect.right - rect.left + (_isAhead2 ? maxAheadInset : maxBehindInset) + \"px\";\n        clazz = _isAhead2 ? \"left\" : \"right\";\n\n        if (isNarrow) {\n          clazz += hasNarrowSpacingAhead ? \"-top\" : \"-bottom\";\n        }\n      } else {\n        var _isAhead3 = rect.top + mainAxisMinWidth <= mainAxisStart;\n\n        insets = _isAhead3 ? aheadInsets : behindInsets;\n        style.top = rect.top - (_isAhead3 ? 0 : maxBehindInset) + \"px\";\n        style.left = subAxisStart + \"px\";\n        style.width = subAxisAvailableWidth + \"px\";\n        style.height = rect.bottom - rect.top + (_isAhead3 ? maxAheadInset : maxBehindInset) + \"px\";\n        clazz = _isAhead3 ? \"top\" : \"bottom\";\n\n        if (isNarrow) {\n          clazz += hasNarrowSpacingAhead ? \"-left\" : \"-right\";\n        }\n      }\n\n      perspective.rects.push(rect);\n      return {\n        id: _.uniqueId(\"marker-\"),\n        number: number,\n        style: style,\n        insets: insets,\n        clazz: clazz\n      };\n    },\n    isValidArray: function isValidArray(array, length) {\n      var ret = array instanceof Array;\n\n      if (length) {\n        ret = ret && array.length === length;\n      }\n\n      return ret;\n    },\n    getPerspective: function getPerspective(pname) {\n      var filteredPerspectives = this.perspectives.filter(function (item) {\n        return item.name === pname;\n      });\n\n      if (filteredPerspectives && filteredPerspectives.length > 0) {\n        return filteredPerspectives[0];\n      }\n\n      return null;\n    },\n    getMarkerOptions: function getMarkerOptions(part, pname) {\n      var options = part.markers;\n\n      if (!options) {\n        return {\n          x: [],\n          y: []\n        };\n      }\n\n      var x, y;\n\n      if (pname === Perspective.Overlook) {\n        x = \"x\";\n        y = \"y\";\n      } else if (pname === Perspective.Side) {\n        x = \"x\";\n        y = \"z\";\n      } else if (pname === Perspective.Front) {\n        x = \"y\";\n        y = \"z\";\n      }\n\n      var optionX = options[x] || [];\n      var optionY = options[y] || [];\n      optionX = optionX.map(function (item) {\n        var insets = item.insets || {};\n        item.mainAxisInsets = insets[y] || {};\n        return item;\n      });\n      optionY = optionY.map(function (item) {\n        var insets = item.insets || {};\n        item.mainAxisInsets = insets[x] || {};\n        return item;\n      });\n      var option = {};\n      option.x = optionX;\n      option.y = optionY;\n      return option;\n    },\n    getRequiredRealOffsetX: function getRequiredRealOffsetX(type, pname) {\n      var _this5 = this;\n\n      if (pname === Perspective.Overlook || pname === Perspective.Side) {\n        return 0;\n      }\n\n      if (type === Perspective.Beam) {\n        return 0;\n      }\n\n      return this.structure.joints.reduce(function (pre, item) {\n        if (item.type !== PartType.Beam) {\n          return pre;\n        }\n\n        return Math.max(item.realY + _this5.typedParts[item.type].realHeight - _this5.structure.realHeight, pre);\n      }, 0);\n    },\n    getRequiredRealOffsetY: function getRequiredRealOffsetY(type, pname) {\n      if (pname === Perspective.Front || pname === Perspective.Side) {\n        return 0;\n      }\n\n      if (type === Perspective.Beam) {\n        return 0;\n      }\n\n      return -this.structure.joints.reduce(function (pre, item) {\n        if (item.type !== PartType.Beam) {\n          return pre;\n        }\n\n        return Math.min(item.realY, pre);\n      }, 0);\n    },\n    getRequiredRealWidth: function getRequiredRealWidth(pname) {\n      var _this6 = this;\n\n      if (pname === Perspective.Overlook || pname === Perspective.Side) {\n        return this.runway.realWidth * this.numberOfRunways;\n      } //主梁height+realY可能超出钢结构的height\n\n\n      var realWidth = this.structure.joints.reduce(function (pre, item) {\n        var ret = Math.max(_this6.structure.realHeight, item.realY + _this6.typedParts[item.type].realHeight);\n\n        if (item.realY < 0) {\n          ret -= item.realY;\n        }\n\n        return Math.max(ret, pre);\n      }, -1);\n      return realWidth;\n    },\n    getRequiredRealHeight: function getRequiredRealHeight(pname) {\n      if (pname === Perspective.Front || pname === Perspective.Side) {\n        return this.structure.realDepth;\n      }\n\n      return this.getRequiredRealWidth(Perspective.Front);\n    },\n    applyStyleToPart: function applyStyleToPart(part, pname, index) {\n      var partType = part.type;\n      var style = {\n        position: \"absolute\"\n      };\n      var width,\n          height,\n          top = 0,\n          left = 0;\n\n      if (pname === Perspective.Overlook) {\n        width = part.realWidth;\n        height = part.realHeight;\n\n        if (partType === PartType.Structure) {\n          var span = (this.getRequiredRealWidth(pname) - this.numberOfStructures * part.realWidth) / (this.numberOfStructures - 1);\n          left = index * (span + part.realWidth);\n        } else if (partType === PartType.Runway) {\n          left = index * part.realWidth;\n        }\n      } else if (pname === Perspective.Side) {\n        width = part.realWidth;\n        height = part.realDepth;\n\n        if (partType === PartType.Structure) {\n          var _span = (this.getRequiredRealWidth(pname) - this.numberOfStructures * part.realWidth) / (this.numberOfStructures - 1);\n\n          left = index * (_span + part.realWidth);\n        } else if (part.type === PartType.Runway) {\n          left = index * part.realWidth;\n        }\n      } else {\n        width = part.realHeight;\n        height = part.realDepth;\n      }\n\n      top += this.getRequiredRealOffsetY(partType, pname);\n      left += this.getRequiredRealOffsetX(partType, pname);\n      var scale = this.scale;\n      style.top = PADDING + top * scale + \"px\";\n      style.left = PADDING + left * scale + \"px\";\n      style.width = width * scale + \"px\";\n      style.height = height * scale + \"px\";\n      part.style = style;\n    },\n    applyJointStyleToPart: function applyJointStyleToPart(part, joint, pname) {\n      var style = part.style || {};\n      var top = 0,\n          left = 0;\n\n      if (pname === Perspective.Overlook) {\n        top = joint.realY;\n        left = joint.realX;\n      } else if (pname === Perspective.Side) {\n        top = joint.realZ;\n        left = joint.realX;\n      } else {\n        top = joint.realZ;\n        left = this.structure.realHeight - joint.realY - part.realHeight;\n      }\n\n      var scale = this.scale;\n      left *= scale;\n      top *= scale;\n      style.left = parseFloat(style.left) + left + \"px\";\n      style.top = parseFloat(style.top) + top + \"px\";\n      part.style = style;\n    },\n    generatePdf: function generatePdf() {\n      this.$refs.html2Pdf.generatePdf();\n    }\n  }\n};",{"version":3,"sources":["ThreeView.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div>\n    <div class=\"form\">\n      <span>长度（毫米）</span>\n      <input type=\"number\" v-model=\"realWidth\" />\n      <button @click=\"reload\">确定</button>\n      <button @click=\"generatePdf\">生成PDF</button>\n    </div>\n    <vue-html2pdf\n      :show-layout=\"true\"\n      :float-layout=\"false\"\n      :enable-download=\"true\"\n      :preview-modal=\"true\"\n      :paginate-elements-by-height=\"1400\"\n      :pdf-quality=\"2\"\n      :manual-pagination=\"false\"\n      pdf-format=\"a4\"\n      pdf-orientation=\"landscape\"\n      pdf-content-width=\"1400px\"\n      ref=\"html2Pdf\"\n      :style=\"{ marginLeft: '100px' }\"\n    >\n      <div class=\"container\" slot=\"pdf-content\">\n        <div\n          class=\"perspective\"\n          v-for=\"perspective in perspectives\"\n          :style=\"perspective.style\"\n          :key=\"perspective.name\"\n        >\n          <!-- <div class=\"rect-container\">\n            <div v-for=\"(rect, index) in perspective.rects\" :key=\"index\"\n              :style=\"{ position: 'absolute', backgroundColor: '#00000011', left: rect.left + 'px', top: rect.top + 'px', width: rect.right - rect.left + 'px', height: rect.bottom - rect.top + 'px' }\" />\n          </div> -->\n          <div class=\"part-container\">\n            <img\n              class=\"part\"\n              v-for=\"part in perspective.parts\"\n              :key=\"part.id\"\n              :style=\"part.style\"\n              crossorigin=\"anonymous\"\n              :src=\"require(`@/assets/${part[perspective.name].image}`)\"\n            />\n          </div>\n          <div class=\"marker-container\">\n            <marker-view\n              :number=\"marker.number\"\n              v-for=\"marker in perspective.markers\"\n              :key=\"marker.id\"\n              :style=\"marker.style\"\n              :clazz=\"marker.clazz\"\n              :insets=\"marker.insets\"\n            />\n          </div>\n        </div>\n      </div>\n    </vue-html2pdf>\n  </div>\n</template>\n\n<script>\n/**\n * 二维坐标系以左上角为原点\n * 三维坐标系以俯视图左上角为原点，Z轴指向屏幕外\n * width：俯视图中的宽（X轴）\n * height：俯视图中的高（Y轴）\n * depth：正视图中的高（Z轴）\n */\n\nimport Vue from \"vue\";\nimport parts from \"@/mock/parts.json\";\nimport MarkerView from \"@/components/MarkerView\";\nimport VueHtml2pdf from \"vue-html2pdf\";\nimport _ from \"lodash\";\n\nconst Perspective = {\n  Front: \"front\",\n  Side: \"side\",\n  Overlook: \"overlook\"\n};\n\nconst PartType = {\n  Beam: \"beam\",\n  Runway: \"runway\",\n  Structure: \"structure\"\n};\n\nconst PADDING = 60;\nconst WIDTH_SCALE = 50;\nconst HEIGHT_SCALE = 100;\nconst MIN_PERSPECTIVE_SIZE = [1200, 1000];\n\nVue.prototype.Perspective = Perspective;\nVue.prototype.PartType = PartType;\n\nexport default {\n  name: \"ThreeView\",\n  components: {\n    MarkerView,\n    VueHtml2pdf\n  },\n  data() {\n    return {\n      realWidth: 20000,\n      perspectives: [\n        {\n          name: Perspective.Overlook,\n          parts: [],\n          markers: [],\n          rects: []\n        },\n        {\n          name: Perspective.Front,\n          parts: [],\n          markers: [],\n          rects: []\n        },\n        {\n          name: Perspective.Side,\n          parts: [],\n          markers: [],\n          rects: []\n        }\n      ],\n      typedParts: {}\n    };\n  },\n  created() {\n    this.typedParts = parts\n      ? parts.reduce((pre, item) => {\n          pre[item.type] = item;\n          return pre;\n        }, {})\n      : {};\n  },\n  mounted() {\n    this.reload();\n  },\n  computed: {\n    beam() {\n      return this.typedParts[PartType.Beam] || {};\n    },\n    runway() {\n      return this.typedParts[PartType.Runway] || {};\n    },\n    structure() {\n      return this.typedParts[PartType.Structure] || {};\n    },\n    scale() {\n      return Math.min(this.widthScale, this.heightScale, 1);\n    },\n    widthScale() {\n      return this.perspectives.reduce((pre, item) => {\n        return Math.min(\n          (this.perspectiveWidth - PADDING * 2) /\n            this.getRequiredRealWidth(item.name),\n          pre\n        );\n      }, 1);\n    },\n    heightScale() {\n      return this.perspectives.reduce((pre, item) => {\n        return Math.min(\n          (this.perspectiveHeight - PADDING * 2) /\n            this.getRequiredRealHeight(item.name),\n          pre\n        );\n      }, 1);\n    },\n    numberOfRunways() {\n      return Math.ceil(this.realWidth / this.runway.realWidth);\n    },\n    numberOfStructures() {\n      return Math.ceil(this.realWidth / this.structure.realSpan) + 1;\n    },\n    numberOfBeams() {\n      return 1;\n    },\n    zoom() {\n      return MIN_PERSPECTIVE_SIZE[0] / this.perspectiveWidth;\n    },\n    perspectiveWidth() {\n      return Math.max(this.realWidth / WIDTH_SCALE, MIN_PERSPECTIVE_SIZE[0]);\n    },\n    perspectiveHeight() {\n      return Math.max(this.realWidth / HEIGHT_SCALE, MIN_PERSPECTIVE_SIZE[1]);\n    }\n  },\n  methods: {\n    reload() {\n      for (let perspective of this.perspectives) {\n        perspective.style = {\n          position: \"relative\",\n          width: this.perspectiveWidth * this.zoom + \"px\",\n          height: this.perspectiveHeight * this.zoom + \"px\",\n          transform: `scale(${this.zoom})`,\n          transformOrigin: \"0 0\"\n        };\n        perspective.parts = [];\n        perspective.markers = [];\n        perspective.rects = [];\n\n        const { name: pname } = perspective;\n\n        const needMarkerParts = [];\n        let lastPart;\n        for (let i = 0; i < this.numberOfStructures; i++) {\n          const part = {\n            id: _.uniqueId(\"part-\"),\n            ...this.structure\n          };\n          this.applyStyleToPart(part, pname, i);\n          this.appendPartRect(part, pname);\n          perspective.parts.push(part);\n\n          if (i === 0) {\n            needMarkerParts.push(part);\n          }\n\n          if (i > 0 && pname === Perspective.Overlook) {\n            let number =\n              (this.realWidth - part.realWidth) / (this.numberOfStructures - 1);\n            number = parseInt(number);\n            const mainAxisStart = parseFloat(lastPart.style.top);\n            const mainAxisEnd =\n              parseFloat(lastPart.style.top) +\n              parseFloat(lastPart.style.height);\n            const subAxisStart =\n              parseFloat(lastPart.style.left) +\n              parseFloat(lastPart.style.width) / 2;\n            const subAxisEnd =\n              parseFloat(part.style.left) +\n              parseFloat(part.style.width) / 2 +\n              1;\n            const marker = this.generateMarker(\n              pname,\n              number,\n              false,\n              mainAxisStart,\n              mainAxisEnd,\n              subAxisStart,\n              subAxisEnd\n            );\n            if (marker) {\n              perspective.markers.push(marker);\n            }\n          }\n          lastPart = part;\n        }\n\n        if (!this.structure.joints) {\n          continue;\n        }\n\n        let hasAppendRunwayMarker = false;\n        let hasAppendBeamMarker = false;\n        for (let joint of this.structure.joints) {\n          if (joint.type === PartType.Runway) {\n            for (let i = 0; i < this.numberOfRunways; i++) {\n              const part = {\n                id: _.uniqueId(\"part-\"),\n                ...this.runway\n              };\n              this.applyStyleToPart(part, pname, i);\n              this.applyJointStyleToPart(part, joint, pname);\n              this.appendPartRect(part, pname);\n              perspective.parts.push(part);\n\n              if (!hasAppendRunwayMarker && i == this.numberOfRunways - 1) {\n                hasAppendRunwayMarker = true;\n                needMarkerParts.push(part);\n              }\n            }\n          }\n\n          if (joint.type === PartType.Beam) {\n            for (let i = 0; i < this.numberOfBeams; i++) {\n              const part = {\n                id: _.uniqueId(\"part-\"),\n                ...this.beam\n              };\n              this.applyStyleToPart(part, pname, i);\n              this.applyJointStyleToPart(part, joint, pname);\n              this.appendPartRect(part, pname);\n              perspective.parts.push(part);\n\n              if (!hasAppendBeamMarker && i == this.numberOfBeams - 1) {\n                hasAppendBeamMarker = true;\n                needMarkerParts.push(part);\n              }\n            }\n          }\n        }\n        needMarkerParts.forEach(item => this.renderPartMarkers(pname, item));\n      }\n    },\n    getMarkerTextWidth(text) {\n      const element = document.createElement(\"canvas\");\n      const context = element.getContext(\"2d\");\n      context.font = \"12px Arial\";\n      return context.measureText(text).width;\n    },\n    renderPartMarkers(pname, part) {\n      const perspective = this.getPerspective(pname);\n      const markerOptions = this.getMarkerOptions(part, pname);\n      Object.entries(markerOptions).forEach(item => {\n        for (let option of item[1]) {\n          const xAxis = item[0] === \"y\";\n          const { top, left, width, height } = part.style;\n          const { range, mainAxisInsets } = option;\n\n          if (!this.isValidArray(range, 2)) {\n            continue;\n          }\n          const number = range[1] - range[0];\n          let mainAxisStart, mainAxisEnd, subAxisStart;\n          if (xAxis) {\n            mainAxisStart = parseFloat(left);\n            mainAxisEnd = parseFloat(left) + parseFloat(width);\n            subAxisStart = parseFloat(top) + range[0] * this.scale;\n          } else {\n            mainAxisStart = parseFloat(top);\n            mainAxisEnd = parseFloat(top) + parseFloat(height);\n            subAxisStart = parseFloat(left) + range[0] * this.scale;\n          }\n          const marker = this.generateMarker(\n            pname,\n            number,\n            xAxis,\n            mainAxisStart,\n            mainAxisEnd,\n            subAxisStart,\n            null,\n            mainAxisInsets.ahead,\n            mainAxisInsets.behind\n          );\n          if (!marker) {\n            continue;\n          }\n          perspective.markers.push(marker);\n        }\n      });\n    },\n    appendPartRect(part, pname) {\n      const { style } = part;\n      const perspective = this.getPerspective(pname);\n      perspective.rects.push({\n        top: parseFloat(style.top),\n        left: parseFloat(style.left),\n        right: parseFloat(style.left) + parseFloat(style.width),\n        bottom: parseFloat(style.top) + parseFloat(style.height)\n      });\n    },\n    isRectOverlap(rect1, rect2) {\n      return !(\n        rect1.right <= rect2.left ||\n        rect1.left >= rect2.right ||\n        rect1.bottom <= rect2.top ||\n        rect1.top >= rect2.bottom\n      );\n    },\n    generateMarker(\n      pname,\n      number,\n      xAxis,\n      mainAxisStart,\n      mainAxisEnd,\n      subAxisStart,\n      subAxisEnd,\n      aheadInsets,\n      behindInsets\n    ) {\n      if (!aheadInsets) {\n        aheadInsets = [0, 0];\n      }\n      if (!behindInsets) {\n        behindInsets = [0, 0];\n      }\n\n      const isValidInsets =\n        this.isValidArray(aheadInsets, 2) && this.isValidArray(behindInsets, 2);\n      if (!isValidInsets) {\n        return null;\n      }\n\n      const perspective = this.getPerspective(pname);\n\n      const style = {};\n\n      const scale = this.scale;\n\n      aheadInsets = aheadInsets.map(item => item * scale);\n      behindInsets = behindInsets.map(item => item * scale);\n\n      const maxAheadInset = Math.max(...aheadInsets);\n      const maxBehindInset = Math.max(...behindInsets);\n\n      let insets;\n\n      let sortedRects = [...perspective.rects];\n      sortedRects.sort((item1, item2) => {\n        if (xAxis) {\n          return item1.left > item2.left ? 1 : -1;\n        }\n        return item1.top > item2.top ? 1 : -1;\n      });\n\n      const mainAxisMinWidth = 20;\n      const subAxisMinArrowWidth = 20;\n      const subAxisAvailableWidth = subAxisEnd\n        ? subAxisEnd - subAxisStart\n        : number * scale;\n      const textWidth = this.getMarkerTextWidth(number);\n      const textHeight = 20;\n      let isNarrow = false;\n      let fixedSize = 0;\n\n      let polyfillRect = {\n        ...sortedRects[0]\n      };\n      if (xAxis) {\n        polyfillRect.right = polyfillRect.left;\n        polyfillRect.left -= Math.max(mainAxisMinWidth, textWidth + 5);\n      } else {\n        polyfillRect.bottom = polyfillRect.top;\n        polyfillRect.top -= mainAxisMinWidth;\n      }\n      sortedRects.unshift(polyfillRect);\n\n      if (xAxis) {\n        isNarrow =\n          subAxisAvailableWidth < subAxisMinArrowWidth * 2 + textHeight;\n        if (isNarrow) {\n          fixedSize =\n            subAxisAvailableWidth + subAxisMinArrowWidth * 2 + textHeight;\n        } else {\n          fixedSize = subAxisAvailableWidth;\n        }\n      } else {\n        isNarrow = subAxisAvailableWidth < subAxisMinArrowWidth * 2 + textWidth;\n        if (isNarrow) {\n          fixedSize =\n            subAxisAvailableWidth + textWidth + subAxisMinArrowWidth * 2;\n        } else {\n          fixedSize = subAxisAvailableWidth;\n        }\n      }\n\n      let narrowOffset = 0;\n      if (isNarrow) {\n        narrowOffset = xAxis\n          ? subAxisMinArrowWidth + textHeight\n          : subAxisMinArrowWidth + textWidth;\n      }\n\n      let rect;\n      let textRect;\n      let arrowRect1;\n      let arrowRect2;\n      let hasNarrowSpacingAhead = true;\n      const arrowWidth = 6;\n      const arrowHeight = 8;\n      for (let i = 0; i < 2; i++) {\n        rect = null;\n        textRect = null;\n        arrowRect1 = null;\n        arrowRect2 = null;\n\n        let minTop,\n          minLeft,\n          maxBottom = 0,\n          maxRight = 0;\n        let hasAvailableRect = false;\n        for (let j = 0; j < sortedRects.length; j++) {\n          const sortedRect = sortedRects[j];\n          if (!minTop) {\n            minTop = sortedRect.top;\n          } else {\n            minTop = Math.min(sortedRect.top, minTop);\n          }\n          if (!minLeft) {\n            minLeft = sortedRect.left;\n          } else {\n            minLeft = Math.min(sortedRect.left, minLeft);\n          }\n          maxRight = Math.max(sortedRect.right, maxRight);\n          maxBottom = Math.max(sortedRect.bottom, maxBottom);\n\n          const isOverlap =\n            !textRect ||\n            this.isRectOverlap(textRect, sortedRect) ||\n            this.isRectOverlap(arrowRect1, sortedRect) ||\n            this.isRectOverlap(arrowRect2, sortedRect);\n          if (isOverlap) {\n            const textSpacing = 5;\n            if (xAxis) {\n              const isAhead =\n                sortedRect.right + mainAxisMinWidth <= mainAxisStart;\n              rect = {\n                top: subAxisStart - narrowOffset,\n                left: isAhead ? sortedRect.right : mainAxisEnd,\n                bottom: subAxisStart - narrowOffset + fixedSize,\n                right: isAhead\n                  ? mainAxisStart\n                  : Math.max(sortedRect.right, mainAxisEnd) + mainAxisMinWidth\n              };\n              textRect = {\n                left:\n                  (isAhead ? rect.left : rect.right - mainAxisMinWidth) -\n                  (textWidth - mainAxisMinWidth) / 2,\n                right:\n                  (isAhead ? rect.left + mainAxisMinWidth : rect.right) +\n                  (textWidth - mainAxisMinWidth) / 2\n              };\n\n              const arrowLeft =\n                (isAhead\n                  ? rect.left + mainAxisMinWidth / 2\n                  : rect.right - mainAxisMinWidth / 2) -\n                arrowWidth / 2;\n              const arrowRight = arrowLeft + arrowWidth;\n\n              arrowRect1 = {\n                left: arrowLeft,\n                right: arrowRight\n              };\n              arrowRect2 = {\n                ...arrowRect1\n              };\n\n              if (isNarrow) {\n                textRect.top = hasNarrowSpacingAhead\n                  ? rect.top\n                  : rect.bottom - textHeight;\n                textRect.bottom = hasNarrowSpacingAhead\n                  ? rect.top + textHeight\n                  : rect.bottom;\n\n                arrowRect1.top =\n                  rect.top + (hasNarrowSpacingAhead ? textHeight : 0);\n                arrowRect1.bottom = arrowRect1.top + subAxisMinArrowWidth;\n\n                arrowRect2.top =\n                  rect.bottom -\n                  subAxisMinArrowWidth -\n                  (hasNarrowSpacingAhead ? 0 : textHeight);\n                arrowRect2.bottom = arrowRect2.top + subAxisMinArrowWidth;\n              } else {\n                textRect.top = (rect.bottom + rect.top - textHeight) / 2;\n                textRect.bottom = textRect.top + textHeight;\n\n                arrowRect1.top = rect.top;\n                arrowRect1.bottom = arrowRect1.top + arrowHeight;\n\n                arrowRect2.top = rect.bottom - arrowHeight;\n                arrowRect2.bottom = rect.bottom;\n              }\n            } else {\n              const isAhead =\n                sortedRect.bottom + mainAxisMinWidth <= mainAxisStart;\n              rect = {\n                top: isAhead ? sortedRect.bottom : mainAxisEnd,\n                left: subAxisStart - narrowOffset,\n                bottom: isAhead\n                  ? mainAxisStart\n                  : Math.max(sortedRect.bottom, mainAxisEnd) + mainAxisMinWidth,\n                right: subAxisStart - narrowOffset + fixedSize\n              };\n              textRect = {\n                top: isAhead ? rect.top : rect.bottom - mainAxisMinWidth,\n                bottom: isAhead ? rect.top + mainAxisMinWidth : rect.bottom\n              };\n\n              const arrowTop =\n                (isAhead\n                  ? rect.top + mainAxisMinWidth / 2\n                  : rect.bottom - mainAxisMinWidth / 2) -\n                arrowWidth / 2;\n              const arrowBottom = arrowTop + arrowWidth;\n\n              arrowRect1 = {\n                top: arrowTop,\n                bottom: arrowBottom\n              };\n              arrowRect2 = {\n                ...arrowRect1\n              };\n\n              if (isNarrow) {\n                textRect.left = hasNarrowSpacingAhead\n                  ? rect.left\n                  : rect.right - textWidth;\n                textRect.right = hasNarrowSpacingAhead\n                  ? rect.left + textWidth\n                  : rect.right;\n\n                arrowRect1.left =\n                  rect.left + (hasNarrowSpacingAhead ? textWidth : 0);\n                arrowRect1.right = arrowRect1.left + subAxisMinArrowWidth;\n\n                arrowRect2.left =\n                  rect.right -\n                  subAxisMinArrowWidth -\n                  (hasNarrowSpacingAhead ? 0 : textWidth);\n                arrowRect2.right = arrowRect2.left + subAxisMinArrowWidth;\n              } else {\n                textRect.left = (rect.right + rect.left - textWidth) / 2;\n                textRect.right = textRect.left + textWidth;\n\n                arrowRect1.left = rect.left;\n                arrowRect1.right = arrowRect1.left + arrowWidth;\n\n                arrowRect2.left = rect.right - arrowWidth;\n                arrowRect2.right = rect.right;\n              }\n            }\n            textRect.left -= textSpacing;\n            textRect.right += textSpacing;\n          } else if (j === sortedRects.length - 1) {\n            hasAvailableRect = true;\n          }\n        }\n\n        if (!hasAvailableRect && isNarrow && i === 0) {\n          narrowOffset = subAxisMinArrowWidth;\n          hasNarrowSpacingAhead = false;\n          continue;\n        }\n\n        let aheadDistance,\n          behindDistance,\n          rectDistance = Infinity;\n        const epsilon = 1;\n        if (xAxis) {\n          aheadDistance = Math.abs(minLeft - mainAxisStart);\n          behindDistance = Math.abs(maxRight - mainAxisEnd);\n          if (hasAvailableRect) {\n            rectDistance =\n              rect.left < mainAxisStart\n                ? mainAxisStart - rect.left\n                : rect.right - mainAxisEnd;\n          }\n          const minDistance = Math.min(\n            aheadDistance,\n            behindDistance,\n            rectDistance\n          );\n          if (Math.abs(minDistance - rectDistance) <= epsilon) {\n            break;\n          }\n          if (minDistance === aheadDistance) {\n            rect.left = minLeft;\n            rect.right = mainAxisStart;\n          } else if (minDistance === behindDistance) {\n            rect.left = mainAxisEnd;\n            rect.right = maxRight + mainAxisMinWidth;\n          }\n        } else {\n          aheadDistance = Math.abs(minTop - mainAxisStart);\n          behindDistance = Math.abs(maxBottom - mainAxisEnd);\n          if (hasAvailableRect) {\n            rectDistance =\n              rect.top < mainAxisStart\n                ? mainAxisStart - rect.top\n                : rect.bottom - mainAxisEnd;\n          }\n          const minDistance = Math.min(\n            aheadDistance,\n            behindDistance,\n            rectDistance\n          );\n          if (Math.abs(minDistance - rectDistance) <= epsilon) {\n            break;\n          }\n          if (minDistance === aheadDistance) {\n            rect.top = minTop;\n            rect.bottom = mainAxisStart;\n          } else if (minDistance === behindDistance) {\n            rect.top = mainAxisEnd;\n            rect.bottom = maxBottom + mainAxisMinWidth;\n          }\n        }\n        break;\n      }\n\n      let clazz;\n      if (xAxis) {\n        const isAhead = rect.left + mainAxisMinWidth <= mainAxisStart;\n        insets = isAhead ? aheadInsets : behindInsets;\n\n        style.top = subAxisStart + \"px\";\n        style.left = rect.left - (isAhead ? 0 : maxBehindInset) + \"px\";\n        style.height = subAxisAvailableWidth + \"px\";\n        style.width =\n          rect.right -\n          rect.left +\n          (isAhead ? maxAheadInset : maxBehindInset) +\n          \"px\";\n\n        clazz = isAhead ? \"left\" : \"right\";\n        if (isNarrow) {\n          clazz += hasNarrowSpacingAhead ? \"-top\" : \"-bottom\";\n        }\n      } else {\n        const isAhead = rect.top + mainAxisMinWidth <= mainAxisStart;\n        insets = isAhead ? aheadInsets : behindInsets;\n\n        style.top = rect.top - (isAhead ? 0 : maxBehindInset) + \"px\";\n        style.left = subAxisStart + \"px\";\n        style.width = subAxisAvailableWidth + \"px\";\n        style.height =\n          rect.bottom -\n          rect.top +\n          (isAhead ? maxAheadInset : maxBehindInset) +\n          \"px\";\n\n        clazz = isAhead ? \"top\" : \"bottom\";\n        if (isNarrow) {\n          clazz += hasNarrowSpacingAhead ? \"-left\" : \"-right\";\n        }\n      }\n      perspective.rects.push(rect);\n      return {\n        id: _.uniqueId(\"marker-\"),\n        number,\n        style,\n        insets,\n        clazz\n      };\n    },\n    isValidArray(array, length) {\n      let ret = array instanceof Array;\n      if (length) {\n        ret = ret && array.length === length;\n      }\n      return ret;\n    },\n    getPerspective(pname) {\n      const filteredPerspectives = this.perspectives.filter(\n        item => item.name === pname\n      );\n      if (filteredPerspectives && filteredPerspectives.length > 0) {\n        return filteredPerspectives[0];\n      }\n      return null;\n    },\n    getMarkerOptions(part, pname) {\n      const { markers: options } = part;\n      if (!options) {\n        return {\n          x: [],\n          y: []\n        };\n      }\n      let x, y;\n      if (pname === Perspective.Overlook) {\n        x = \"x\";\n        y = \"y\";\n      } else if (pname === Perspective.Side) {\n        x = \"x\";\n        y = \"z\";\n      } else if (pname === Perspective.Front) {\n        x = \"y\";\n        y = \"z\";\n      }\n      let optionX = options[x] || [];\n      let optionY = options[y] || [];\n\n      optionX = optionX.map(item => {\n        const insets = item.insets || {};\n        item.mainAxisInsets = insets[y] || {};\n        return item;\n      });\n\n      optionY = optionY.map(item => {\n        const insets = item.insets || {};\n        item.mainAxisInsets = insets[x] || {};\n        return item;\n      });\n\n      const option = {};\n      option.x = optionX;\n      option.y = optionY;\n      return option;\n    },\n    getRequiredRealOffsetX(type, pname) {\n      if (pname === Perspective.Overlook || pname === Perspective.Side) {\n        return 0;\n      }\n\n      if (type === Perspective.Beam) {\n        return 0;\n      }\n\n      return this.structure.joints.reduce((pre, item) => {\n        if (item.type !== PartType.Beam) {\n          return pre;\n        }\n        return Math.max(\n          item.realY +\n            this.typedParts[item.type].realHeight -\n            this.structure.realHeight,\n          pre\n        );\n      }, 0);\n    },\n    getRequiredRealOffsetY(type, pname) {\n      if (pname === Perspective.Front || pname === Perspective.Side) {\n        return 0;\n      }\n\n      if (type === Perspective.Beam) {\n        return 0;\n      }\n      return -this.structure.joints.reduce((pre, item) => {\n        if (item.type !== PartType.Beam) {\n          return pre;\n        }\n        return Math.min(item.realY, pre);\n      }, 0);\n    },\n    getRequiredRealWidth(pname) {\n      if (pname === Perspective.Overlook || pname === Perspective.Side) {\n        return this.runway.realWidth * this.numberOfRunways;\n      }\n      //主梁height+realY可能超出钢结构的height\n      const realWidth = this.structure.joints.reduce((pre, item) => {\n        let ret = Math.max(\n          this.structure.realHeight,\n          item.realY + this.typedParts[item.type].realHeight\n        );\n        if (item.realY < 0) {\n          ret -= item.realY;\n        }\n        return Math.max(ret, pre);\n      }, -1);\n      return realWidth;\n    },\n    getRequiredRealHeight(pname) {\n      if (pname === Perspective.Front || pname === Perspective.Side) {\n        return this.structure.realDepth;\n      }\n      return this.getRequiredRealWidth(Perspective.Front);\n    },\n    applyStyleToPart(part, pname, index) {\n      const { type: partType } = part;\n      let style = {\n        position: \"absolute\"\n      };\n\n      let width,\n        height,\n        top = 0,\n        left = 0;\n      if (pname === Perspective.Overlook) {\n        width = part.realWidth;\n        height = part.realHeight;\n        if (partType === PartType.Structure) {\n          const span =\n            (this.getRequiredRealWidth(pname) -\n              this.numberOfStructures * part.realWidth) /\n            (this.numberOfStructures - 1);\n          left = index * (span + part.realWidth);\n        } else if (partType === PartType.Runway) {\n          left = index * part.realWidth;\n        }\n      } else if (pname === Perspective.Side) {\n        width = part.realWidth;\n        height = part.realDepth;\n        if (partType === PartType.Structure) {\n          const span =\n            (this.getRequiredRealWidth(pname) -\n              this.numberOfStructures * part.realWidth) /\n            (this.numberOfStructures - 1);\n          left = index * (span + part.realWidth);\n        } else if (part.type === PartType.Runway) {\n          left = index * part.realWidth;\n        }\n      } else {\n        width = part.realHeight;\n        height = part.realDepth;\n      }\n\n      top += this.getRequiredRealOffsetY(partType, pname);\n      left += this.getRequiredRealOffsetX(partType, pname);\n\n      const scale = this.scale;\n\n      style.top = PADDING + top * scale + \"px\";\n      style.left = PADDING + left * scale + \"px\";\n      style.width = width * scale + \"px\";\n      style.height = height * scale + \"px\";\n      part.style = style;\n    },\n    applyJointStyleToPart(part, joint, pname) {\n      const style = part.style || {};\n      let top = 0,\n        left = 0;\n      if (pname === Perspective.Overlook) {\n        top = joint.realY;\n        left = joint.realX;\n      } else if (pname === Perspective.Side) {\n        top = joint.realZ;\n        left = joint.realX;\n      } else {\n        top = joint.realZ;\n        left = this.structure.realHeight - joint.realY - part.realHeight;\n      }\n\n      const scale = this.scale;\n      left *= scale;\n      top *= scale;\n\n      style.left = parseFloat(style.left) + left + \"px\";\n      style.top = parseFloat(style.top) + top + \"px\";\n\n      part.style = style;\n    },\n    generatePdf() {\n      this.$refs.html2Pdf.generatePdf();\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.form {\n  height: 80px;\n  display: flex;\n  align-items: center;\n  font-size: 14px;\n\n  span {\n    margin-left: 12px;\n    margin-right: 12px;\n    line-height: 24px;\n  }\n\n  input {\n    height: 24px;\n    margin-right: 12px;\n  }\n\n  button {\n    height: 24px;\n    margin-right: 12px;\n  }\n}\n\n.container {\n  width: 100%;\n  // border: 1px solid #ccc;\n\n  .perspective {\n    // border: 1px solid #ccc;\n    // margin: 15px;\n    display: inline-block;\n\n    .marker-container {\n      position: absolute;\n      width: 100%;\n      height: 100%;\n    }\n  }\n}\n</style>"],"sourceRoot":"src/components"}]}