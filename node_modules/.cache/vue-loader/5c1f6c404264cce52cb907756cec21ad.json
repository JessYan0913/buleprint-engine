{"remainingRequest":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/yanheng/Documents/work/web/terino-drawing-engine/src/components/ThreeView.vue?vue&type=style&index=0&id=fe90383a&lang=scss&scoped=true&","dependencies":[{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/src/components/ThreeView.vue","mtime":1617110191483},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/css-loader/index.js","mtime":499162500000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanheng/Documents/work/web/terino-drawing-engine/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.form {\n  height: 80px;\n  display: flex;\n  align-items: center;\n  font-size: 14px;\n\n  span {\n    margin-left: 12px;\n    margin-right: 12px;\n    line-height: 24px;\n  }\n\n  input {\n    height: 24px;\n    margin-right: 12px;\n  }\n\n  button {\n    height: 24px;\n    margin-right: 12px;\n  }\n}\n\n.container {\n  width: 100%;\n  // border: 1px solid #ccc;\n\n  .perspective {\n    // border: 1px solid #ccc;\n    // margin: 15px;\n    display: inline-block;\n\n    .marker-container {\n      position: absolute;\n      width: 100%;\n      height: 100%;\n    }\n  }\n}\n",{"version":3,"sources":["ThreeView.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA65BA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ThreeView.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div class=\"form\">\n      <span>长度（毫米）</span>\n      <input type=\"number\" v-model=\"realWidth\" />\n      <button @click=\"reload\">确定</button>\n      <button @click=\"generatePdf\">生成PDF</button>\n    </div>\n    <vue-html2pdf\n      :show-layout=\"true\"\n      :float-layout=\"false\"\n      :enable-download=\"true\"\n      :preview-modal=\"true\"\n      :paginate-elements-by-height=\"1400\"\n      :pdf-quality=\"2\"\n      :manual-pagination=\"false\"\n      pdf-format=\"a4\"\n      pdf-orientation=\"landscape\"\n      pdf-content-width=\"1400px\"\n      ref=\"html2Pdf\"\n      :style=\"{ marginLeft: '100px' }\"\n    >\n      <div class=\"container\" slot=\"pdf-content\">\n        <div\n          class=\"perspective\"\n          v-for=\"perspective in perspectives\"\n          :style=\"perspective.style\"\n          :key=\"perspective.name\"\n        >\n          <!-- <div class=\"rect-container\">\n            <div v-for=\"(rect, index) in perspective.rects\" :key=\"index\"\n              :style=\"{ position: 'absolute', backgroundColor: '#00000011', left: rect.left + 'px', top: rect.top + 'px', width: rect.right - rect.left + 'px', height: rect.bottom - rect.top + 'px' }\" />\n          </div> -->\n          <div class=\"part-container\">\n            <img\n              class=\"part\"\n              v-for=\"part in perspective.parts\"\n              :key=\"part.id\"\n              :style=\"part.style\"\n              crossorigin=\"anonymous\"\n              :src=\"require(`@/assets/${part[perspective.name].image}`)\"\n            />\n          </div>\n          <div class=\"marker-container\">\n            <marker-view\n              :number=\"marker.number\"\n              v-for=\"marker in perspective.markers\"\n              :key=\"marker.id\"\n              :style=\"marker.style\"\n              :clazz=\"marker.clazz\"\n              :insets=\"marker.insets\"\n            />\n          </div>\n        </div>\n      </div>\n    </vue-html2pdf>\n  </div>\n</template>\n\n<script>\n/**\n * 二维坐标系以左上角为原点\n * 三维坐标系以俯视图左上角为原点，Z轴指向屏幕外\n * width：俯视图中的宽（X轴）\n * height：俯视图中的高（Y轴）\n * depth：正视图中的高（Z轴）\n */\n\nimport Vue from \"vue\";\nimport parts from \"@/mock/parts.json\";\nimport MarkerView from \"@/components/MarkerView\";\nimport VueHtml2pdf from \"vue-html2pdf\";\nimport _ from \"lodash\";\n\nconst Perspective = {\n  Front: \"front\",\n  Side: \"side\",\n  Overlook: \"overlook\"\n};\n\nconst PartType = {\n  Beam: \"beam\",\n  Runway: \"runway\",\n  Structure: \"structure\"\n};\n\nconst PADDING = 60;\nconst WIDTH_SCALE = 50;\nconst HEIGHT_SCALE = 100;\nconst MIN_PERSPECTIVE_SIZE = [1200, 1000];\n\nVue.prototype.Perspective = Perspective;\nVue.prototype.PartType = PartType;\n\nexport default {\n  name: \"ThreeView\",\n  components: {\n    MarkerView,\n    VueHtml2pdf\n  },\n  data() {\n    return {\n      realWidth: 20000,\n      perspectives: [\n        {\n          name: Perspective.Overlook,\n          parts: [],\n          markers: [],\n          rects: []\n        },\n        {\n          name: Perspective.Front,\n          parts: [],\n          markers: [],\n          rects: []\n        },\n        {\n          name: Perspective.Side,\n          parts: [],\n          markers: [],\n          rects: []\n        }\n      ],\n      typedParts: {}\n    };\n  },\n  created() {\n    this.typedParts = parts\n      ? parts.reduce((pre, item) => {\n          pre[item.type] = item;\n          return pre;\n        }, {})\n      : {};\n  },\n  mounted() {\n    this.reload();\n  },\n  computed: {\n    beam() {\n      return this.typedParts[PartType.Beam] || {};\n    },\n    runway() {\n      return this.typedParts[PartType.Runway] || {};\n    },\n    structure() {\n      return this.typedParts[PartType.Structure] || {};\n    },\n    scale() {\n      return Math.min(this.widthScale, this.heightScale, 1);\n    },\n    widthScale() {\n      return this.perspectives.reduce((pre, item) => {\n        return Math.min(\n          (this.perspectiveWidth - PADDING * 2) /\n            this.getRequiredRealWidth(item.name),\n          pre\n        );\n      }, 1);\n    },\n    heightScale() {\n      return this.perspectives.reduce((pre, item) => {\n        return Math.min(\n          (this.perspectiveHeight - PADDING * 2) /\n            this.getRequiredRealHeight(item.name),\n          pre\n        );\n      }, 1);\n    },\n    numberOfRunways() {\n      return Math.ceil(this.realWidth / this.runway.realWidth);\n    },\n    numberOfStructures() {\n      return Math.ceil(this.realWidth / this.structure.realSpan) + 1;\n    },\n    numberOfBeams() {\n      return 1;\n    },\n    zoom() {\n      return MIN_PERSPECTIVE_SIZE[0] / this.perspectiveWidth;\n    },\n    perspectiveWidth() {\n      return Math.max(this.realWidth / WIDTH_SCALE, MIN_PERSPECTIVE_SIZE[0]);\n    },\n    perspectiveHeight() {\n      return Math.max(this.realWidth / HEIGHT_SCALE, MIN_PERSPECTIVE_SIZE[1]);\n    }\n  },\n  methods: {\n    reload() {\n      for (let perspective of this.perspectives) {\n        perspective.style = {\n          position: \"relative\",\n          width: this.perspectiveWidth * this.zoom + \"px\",\n          height: this.perspectiveHeight * this.zoom + \"px\",\n          transform: `scale(${this.zoom})`,\n          transformOrigin: \"0 0\"\n        };\n        perspective.parts = [];\n        perspective.markers = [];\n        perspective.rects = [];\n\n        const { name: pname } = perspective;\n\n        const needMarkerParts = [];\n        let lastPart;\n        for (let i = 0; i < this.numberOfStructures; i++) {\n          const part = {\n            id: _.uniqueId(\"part-\"),\n            ...this.structure\n          };\n          this.applyStyleToPart(part, pname, i);\n          this.appendPartRect(part, pname);\n          perspective.parts.push(part);\n\n          if (i === 0) {\n            needMarkerParts.push(part);\n          }\n\n          if (i > 0 && pname === Perspective.Overlook) {\n            let number =\n              (this.realWidth - part.realWidth) / (this.numberOfStructures - 1);\n            number = parseInt(number);\n            const mainAxisStart = parseFloat(lastPart.style.top);\n            const mainAxisEnd =\n              parseFloat(lastPart.style.top) +\n              parseFloat(lastPart.style.height);\n            const subAxisStart =\n              parseFloat(lastPart.style.left) +\n              parseFloat(lastPart.style.width) / 2;\n            const subAxisEnd =\n              parseFloat(part.style.left) +\n              parseFloat(part.style.width) / 2 +\n              1;\n            const marker = this.generateMarker(\n              pname,\n              number,\n              false,\n              mainAxisStart,\n              mainAxisEnd,\n              subAxisStart,\n              subAxisEnd\n            );\n            if (marker) {\n              perspective.markers.push(marker);\n            }\n          }\n          lastPart = part;\n        }\n\n        if (!this.structure.joints) {\n          continue;\n        }\n\n        let hasAppendRunwayMarker = false;\n        let hasAppendBeamMarker = false;\n        for (let joint of this.structure.joints) {\n          if (joint.type === PartType.Runway) {\n            for (let i = 0; i < this.numberOfRunways; i++) {\n              const part = {\n                id: _.uniqueId(\"part-\"),\n                ...this.runway\n              };\n              this.applyStyleToPart(part, pname, i);\n              this.applyJointStyleToPart(part, joint, pname);\n              this.appendPartRect(part, pname);\n              perspective.parts.push(part);\n\n              if (!hasAppendRunwayMarker && i == this.numberOfRunways - 1) {\n                hasAppendRunwayMarker = true;\n                needMarkerParts.push(part);\n              }\n            }\n          }\n\n          if (joint.type === PartType.Beam) {\n            for (let i = 0; i < this.numberOfBeams; i++) {\n              const part = {\n                id: _.uniqueId(\"part-\"),\n                ...this.beam\n              };\n              this.applyStyleToPart(part, pname, i);\n              this.applyJointStyleToPart(part, joint, pname);\n              this.appendPartRect(part, pname);\n              perspective.parts.push(part);\n\n              if (!hasAppendBeamMarker && i == this.numberOfBeams - 1) {\n                hasAppendBeamMarker = true;\n                needMarkerParts.push(part);\n              }\n            }\n          }\n        }\n        needMarkerParts.forEach(item => this.renderPartMarkers(pname, item));\n      }\n    },\n    getMarkerTextWidth(text) {\n      const element = document.createElement(\"canvas\");\n      const context = element.getContext(\"2d\");\n      context.font = \"12px Arial\";\n      return context.measureText(text).width;\n    },\n    renderPartMarkers(pname, part) {\n      const perspective = this.getPerspective(pname);\n      const markerOptions = this.getMarkerOptions(part, pname);\n      Object.entries(markerOptions).forEach(item => {\n        for (let option of item[1]) {\n          const xAxis = item[0] === \"y\";\n          const { top, left, width, height } = part.style;\n          const { range, mainAxisInsets } = option;\n\n          if (!this.isValidArray(range, 2)) {\n            continue;\n          }\n          const number = range[1] - range[0];\n          let mainAxisStart, mainAxisEnd, subAxisStart;\n          if (xAxis) {\n            mainAxisStart = parseFloat(left);\n            mainAxisEnd = parseFloat(left) + parseFloat(width);\n            subAxisStart = parseFloat(top) + range[0] * this.scale;\n          } else {\n            mainAxisStart = parseFloat(top);\n            mainAxisEnd = parseFloat(top) + parseFloat(height);\n            subAxisStart = parseFloat(left) + range[0] * this.scale;\n          }\n          const marker = this.generateMarker(\n            pname,\n            number,\n            xAxis,\n            mainAxisStart,\n            mainAxisEnd,\n            subAxisStart,\n            null,\n            mainAxisInsets.ahead,\n            mainAxisInsets.behind\n          );\n          if (!marker) {\n            continue;\n          }\n          perspective.markers.push(marker);\n        }\n      });\n    },\n    appendPartRect(part, pname) {\n      const { style } = part;\n      const perspective = this.getPerspective(pname);\n      perspective.rects.push({\n        top: parseFloat(style.top),\n        left: parseFloat(style.left),\n        right: parseFloat(style.left) + parseFloat(style.width),\n        bottom: parseFloat(style.top) + parseFloat(style.height)\n      });\n    },\n    isRectOverlap(rect1, rect2) {\n      return !(\n        rect1.right <= rect2.left ||\n        rect1.left >= rect2.right ||\n        rect1.bottom <= rect2.top ||\n        rect1.top >= rect2.bottom\n      );\n    },\n    generateMarker(\n      pname,\n      number,\n      xAxis,\n      mainAxisStart,\n      mainAxisEnd,\n      subAxisStart,\n      subAxisEnd,\n      aheadInsets,\n      behindInsets\n    ) {\n      if (!aheadInsets) {\n        aheadInsets = [0, 0];\n      }\n      if (!behindInsets) {\n        behindInsets = [0, 0];\n      }\n\n      const isValidInsets =\n        this.isValidArray(aheadInsets, 2) && this.isValidArray(behindInsets, 2);\n      if (!isValidInsets) {\n        return null;\n      }\n\n      const perspective = this.getPerspective(pname);\n\n      const style = {};\n\n      const scale = this.scale;\n\n      aheadInsets = aheadInsets.map(item => item * scale);\n      behindInsets = behindInsets.map(item => item * scale);\n\n      const maxAheadInset = Math.max(...aheadInsets);\n      const maxBehindInset = Math.max(...behindInsets);\n\n      let insets;\n\n      let sortedRects = [...perspective.rects];\n      sortedRects.sort((item1, item2) => {\n        if (xAxis) {\n          return item1.left > item2.left ? 1 : -1;\n        }\n        return item1.top > item2.top ? 1 : -1;\n      });\n\n      const mainAxisMinWidth = 20;\n      const subAxisMinArrowWidth = 20;\n      const subAxisAvailableWidth = subAxisEnd\n        ? subAxisEnd - subAxisStart\n        : number * scale;\n      const textWidth = this.getMarkerTextWidth(number);\n      const textHeight = 20;\n      let isNarrow = false;\n      let fixedSize = 0;\n\n      let polyfillRect = {\n        ...sortedRects[0]\n      };\n      if (xAxis) {\n        polyfillRect.right = polyfillRect.left;\n        polyfillRect.left -= Math.max(mainAxisMinWidth, textWidth + 5);\n      } else {\n        polyfillRect.bottom = polyfillRect.top;\n        polyfillRect.top -= mainAxisMinWidth;\n      }\n      sortedRects.unshift(polyfillRect);\n\n      if (xAxis) {\n        isNarrow =\n          subAxisAvailableWidth < subAxisMinArrowWidth * 2 + textHeight;\n        if (isNarrow) {\n          fixedSize =\n            subAxisAvailableWidth + subAxisMinArrowWidth * 2 + textHeight;\n        } else {\n          fixedSize = subAxisAvailableWidth;\n        }\n      } else {\n        isNarrow = subAxisAvailableWidth < subAxisMinArrowWidth * 2 + textWidth;\n        if (isNarrow) {\n          fixedSize =\n            subAxisAvailableWidth + textWidth + subAxisMinArrowWidth * 2;\n        } else {\n          fixedSize = subAxisAvailableWidth;\n        }\n      }\n\n      let narrowOffset = 0;\n      if (isNarrow) {\n        narrowOffset = xAxis\n          ? subAxisMinArrowWidth + textHeight\n          : subAxisMinArrowWidth + textWidth;\n      }\n\n      let rect;\n      let textRect;\n      let arrowRect1;\n      let arrowRect2;\n      let hasNarrowSpacingAhead = true;\n      const arrowWidth = 6;\n      const arrowHeight = 8;\n      for (let i = 0; i < 2; i++) {\n        rect = null;\n        textRect = null;\n        arrowRect1 = null;\n        arrowRect2 = null;\n\n        let minTop,\n          minLeft,\n          maxBottom = 0,\n          maxRight = 0;\n        let hasAvailableRect = false;\n        for (let j = 0; j < sortedRects.length; j++) {\n          const sortedRect = sortedRects[j];\n          if (!minTop) {\n            minTop = sortedRect.top;\n          } else {\n            minTop = Math.min(sortedRect.top, minTop);\n          }\n          if (!minLeft) {\n            minLeft = sortedRect.left;\n          } else {\n            minLeft = Math.min(sortedRect.left, minLeft);\n          }\n          maxRight = Math.max(sortedRect.right, maxRight);\n          maxBottom = Math.max(sortedRect.bottom, maxBottom);\n\n          const isOverlap =\n            !textRect ||\n            this.isRectOverlap(textRect, sortedRect) ||\n            this.isRectOverlap(arrowRect1, sortedRect) ||\n            this.isRectOverlap(arrowRect2, sortedRect);\n          if (isOverlap) {\n            const textSpacing = 5;\n            if (xAxis) {\n              const isAhead =\n                sortedRect.right + mainAxisMinWidth <= mainAxisStart;\n              rect = {\n                top: subAxisStart - narrowOffset,\n                left: isAhead ? sortedRect.right : mainAxisEnd,\n                bottom: subAxisStart - narrowOffset + fixedSize,\n                right: isAhead\n                  ? mainAxisStart\n                  : Math.max(sortedRect.right, mainAxisEnd) + mainAxisMinWidth\n              };\n              textRect = {\n                left:\n                  (isAhead ? rect.left : rect.right - mainAxisMinWidth) -\n                  (textWidth - mainAxisMinWidth) / 2,\n                right:\n                  (isAhead ? rect.left + mainAxisMinWidth : rect.right) +\n                  (textWidth - mainAxisMinWidth) / 2\n              };\n\n              const arrowLeft =\n                (isAhead\n                  ? rect.left + mainAxisMinWidth / 2\n                  : rect.right - mainAxisMinWidth / 2) -\n                arrowWidth / 2;\n              const arrowRight = arrowLeft + arrowWidth;\n\n              arrowRect1 = {\n                left: arrowLeft,\n                right: arrowRight\n              };\n              arrowRect2 = {\n                ...arrowRect1\n              };\n\n              if (isNarrow) {\n                textRect.top = hasNarrowSpacingAhead\n                  ? rect.top\n                  : rect.bottom - textHeight;\n                textRect.bottom = hasNarrowSpacingAhead\n                  ? rect.top + textHeight\n                  : rect.bottom;\n\n                arrowRect1.top =\n                  rect.top + (hasNarrowSpacingAhead ? textHeight : 0);\n                arrowRect1.bottom = arrowRect1.top + subAxisMinArrowWidth;\n\n                arrowRect2.top =\n                  rect.bottom -\n                  subAxisMinArrowWidth -\n                  (hasNarrowSpacingAhead ? 0 : textHeight);\n                arrowRect2.bottom = arrowRect2.top + subAxisMinArrowWidth;\n              } else {\n                textRect.top = (rect.bottom + rect.top - textHeight) / 2;\n                textRect.bottom = textRect.top + textHeight;\n\n                arrowRect1.top = rect.top;\n                arrowRect1.bottom = arrowRect1.top + arrowHeight;\n\n                arrowRect2.top = rect.bottom - arrowHeight;\n                arrowRect2.bottom = rect.bottom;\n              }\n            } else {\n              const isAhead =\n                sortedRect.bottom + mainAxisMinWidth <= mainAxisStart;\n              rect = {\n                top: isAhead ? sortedRect.bottom : mainAxisEnd,\n                left: subAxisStart - narrowOffset,\n                bottom: isAhead\n                  ? mainAxisStart\n                  : Math.max(sortedRect.bottom, mainAxisEnd) + mainAxisMinWidth,\n                right: subAxisStart - narrowOffset + fixedSize\n              };\n              textRect = {\n                top: isAhead ? rect.top : rect.bottom - mainAxisMinWidth,\n                bottom: isAhead ? rect.top + mainAxisMinWidth : rect.bottom\n              };\n\n              const arrowTop =\n                (isAhead\n                  ? rect.top + mainAxisMinWidth / 2\n                  : rect.bottom - mainAxisMinWidth / 2) -\n                arrowWidth / 2;\n              const arrowBottom = arrowTop + arrowWidth;\n\n              arrowRect1 = {\n                top: arrowTop,\n                bottom: arrowBottom\n              };\n              arrowRect2 = {\n                ...arrowRect1\n              };\n\n              if (isNarrow) {\n                textRect.left = hasNarrowSpacingAhead\n                  ? rect.left\n                  : rect.right - textWidth;\n                textRect.right = hasNarrowSpacingAhead\n                  ? rect.left + textWidth\n                  : rect.right;\n\n                arrowRect1.left =\n                  rect.left + (hasNarrowSpacingAhead ? textWidth : 0);\n                arrowRect1.right = arrowRect1.left + subAxisMinArrowWidth;\n\n                arrowRect2.left =\n                  rect.right -\n                  subAxisMinArrowWidth -\n                  (hasNarrowSpacingAhead ? 0 : textWidth);\n                arrowRect2.right = arrowRect2.left + subAxisMinArrowWidth;\n              } else {\n                textRect.left = (rect.right + rect.left - textWidth) / 2;\n                textRect.right = textRect.left + textWidth;\n\n                arrowRect1.left = rect.left;\n                arrowRect1.right = arrowRect1.left + arrowWidth;\n\n                arrowRect2.left = rect.right - arrowWidth;\n                arrowRect2.right = rect.right;\n              }\n            }\n            textRect.left -= textSpacing;\n            textRect.right += textSpacing;\n          } else if (j === sortedRects.length - 1) {\n            hasAvailableRect = true;\n          }\n        }\n\n        if (!hasAvailableRect && isNarrow && i === 0) {\n          narrowOffset = subAxisMinArrowWidth;\n          hasNarrowSpacingAhead = false;\n          continue;\n        }\n\n        let aheadDistance,\n          behindDistance,\n          rectDistance = Infinity;\n        const epsilon = 1;\n        if (xAxis) {\n          aheadDistance = Math.abs(minLeft - mainAxisStart);\n          behindDistance = Math.abs(maxRight - mainAxisEnd);\n          if (hasAvailableRect) {\n            rectDistance =\n              rect.left < mainAxisStart\n                ? mainAxisStart - rect.left\n                : rect.right - mainAxisEnd;\n          }\n          const minDistance = Math.min(\n            aheadDistance,\n            behindDistance,\n            rectDistance\n          );\n          if (Math.abs(minDistance - rectDistance) <= epsilon) {\n            break;\n          }\n          if (minDistance === aheadDistance) {\n            rect.left = minLeft;\n            rect.right = mainAxisStart;\n          } else if (minDistance === behindDistance) {\n            rect.left = mainAxisEnd;\n            rect.right = maxRight + mainAxisMinWidth;\n          }\n        } else {\n          aheadDistance = Math.abs(minTop - mainAxisStart);\n          behindDistance = Math.abs(maxBottom - mainAxisEnd);\n          if (hasAvailableRect) {\n            rectDistance =\n              rect.top < mainAxisStart\n                ? mainAxisStart - rect.top\n                : rect.bottom - mainAxisEnd;\n          }\n          const minDistance = Math.min(\n            aheadDistance,\n            behindDistance,\n            rectDistance\n          );\n          if (Math.abs(minDistance - rectDistance) <= epsilon) {\n            break;\n          }\n          if (minDistance === aheadDistance) {\n            rect.top = minTop;\n            rect.bottom = mainAxisStart;\n          } else if (minDistance === behindDistance) {\n            rect.top = mainAxisEnd;\n            rect.bottom = maxBottom + mainAxisMinWidth;\n          }\n        }\n        break;\n      }\n\n      let clazz;\n      if (xAxis) {\n        const isAhead = rect.left + mainAxisMinWidth <= mainAxisStart;\n        insets = isAhead ? aheadInsets : behindInsets;\n\n        style.top = subAxisStart + \"px\";\n        style.left = rect.left - (isAhead ? 0 : maxBehindInset) + \"px\";\n        style.height = subAxisAvailableWidth + \"px\";\n        style.width =\n          rect.right -\n          rect.left +\n          (isAhead ? maxAheadInset : maxBehindInset) +\n          \"px\";\n\n        clazz = isAhead ? \"left\" : \"right\";\n        if (isNarrow) {\n          clazz += hasNarrowSpacingAhead ? \"-top\" : \"-bottom\";\n        }\n      } else {\n        const isAhead = rect.top + mainAxisMinWidth <= mainAxisStart;\n        insets = isAhead ? aheadInsets : behindInsets;\n\n        style.top = rect.top - (isAhead ? 0 : maxBehindInset) + \"px\";\n        style.left = subAxisStart + \"px\";\n        style.width = subAxisAvailableWidth + \"px\";\n        style.height =\n          rect.bottom -\n          rect.top +\n          (isAhead ? maxAheadInset : maxBehindInset) +\n          \"px\";\n\n        clazz = isAhead ? \"top\" : \"bottom\";\n        if (isNarrow) {\n          clazz += hasNarrowSpacingAhead ? \"-left\" : \"-right\";\n        }\n      }\n      perspective.rects.push(rect);\n      return {\n        id: _.uniqueId(\"marker-\"),\n        number,\n        style,\n        insets,\n        clazz\n      };\n    },\n    isValidArray(array, length) {\n      let ret = array instanceof Array;\n      if (length) {\n        ret = ret && array.length === length;\n      }\n      return ret;\n    },\n    getPerspective(pname) {\n      const filteredPerspectives = this.perspectives.filter(\n        item => item.name === pname\n      );\n      if (filteredPerspectives && filteredPerspectives.length > 0) {\n        return filteredPerspectives[0];\n      }\n      return null;\n    },\n    getMarkerOptions(part, pname) {\n      const { markers: options } = part;\n      if (!options) {\n        return {\n          x: [],\n          y: []\n        };\n      }\n      let x, y;\n      if (pname === Perspective.Overlook) {\n        x = \"x\";\n        y = \"y\";\n      } else if (pname === Perspective.Side) {\n        x = \"x\";\n        y = \"z\";\n      } else if (pname === Perspective.Front) {\n        x = \"y\";\n        y = \"z\";\n      }\n      let optionX = options[x] || [];\n      let optionY = options[y] || [];\n\n      optionX = optionX.map(item => {\n        const insets = item.insets || {};\n        item.mainAxisInsets = insets[y] || {};\n        return item;\n      });\n\n      optionY = optionY.map(item => {\n        const insets = item.insets || {};\n        item.mainAxisInsets = insets[x] || {};\n        return item;\n      });\n\n      const option = {};\n      option.x = optionX;\n      option.y = optionY;\n      return option;\n    },\n    getRequiredRealOffsetX(type, pname) {\n      if (pname === Perspective.Overlook || pname === Perspective.Side) {\n        return 0;\n      }\n\n      if (type === Perspective.Beam) {\n        return 0;\n      }\n\n      return this.structure.joints.reduce((pre, item) => {\n        if (item.type !== PartType.Beam) {\n          return pre;\n        }\n        return Math.max(\n          item.realY +\n            this.typedParts[item.type].realHeight -\n            this.structure.realHeight,\n          pre\n        );\n      }, 0);\n    },\n    getRequiredRealOffsetY(type, pname) {\n      if (pname === Perspective.Front || pname === Perspective.Side) {\n        return 0;\n      }\n\n      if (type === Perspective.Beam) {\n        return 0;\n      }\n      return -this.structure.joints.reduce((pre, item) => {\n        if (item.type !== PartType.Beam) {\n          return pre;\n        }\n        return Math.min(item.realY, pre);\n      }, 0);\n    },\n    getRequiredRealWidth(pname) {\n      if (pname === Perspective.Overlook || pname === Perspective.Side) {\n        return this.runway.realWidth * this.numberOfRunways;\n      }\n      //主梁height+realY可能超出钢结构的height\n      const realWidth = this.structure.joints.reduce((pre, item) => {\n        let ret = Math.max(\n          this.structure.realHeight,\n          item.realY + this.typedParts[item.type].realHeight\n        );\n        if (item.realY < 0) {\n          ret -= item.realY;\n        }\n        return Math.max(ret, pre);\n      }, -1);\n      return realWidth;\n    },\n    getRequiredRealHeight(pname) {\n      if (pname === Perspective.Front || pname === Perspective.Side) {\n        return this.structure.realDepth;\n      }\n      return this.getRequiredRealWidth(Perspective.Front);\n    },\n    applyStyleToPart(part, pname, index) {\n      const { type: partType } = part;\n      let style = {\n        position: \"absolute\"\n      };\n\n      let width,\n        height,\n        top = 0,\n        left = 0;\n      if (pname === Perspective.Overlook) {\n        width = part.realWidth;\n        height = part.realHeight;\n        if (partType === PartType.Structure) {\n          const span =\n            (this.getRequiredRealWidth(pname) -\n              this.numberOfStructures * part.realWidth) /\n            (this.numberOfStructures - 1);\n          left = index * (span + part.realWidth);\n        } else if (partType === PartType.Runway) {\n          left = index * part.realWidth;\n        }\n      } else if (pname === Perspective.Side) {\n        width = part.realWidth;\n        height = part.realDepth;\n        if (partType === PartType.Structure) {\n          const span =\n            (this.getRequiredRealWidth(pname) -\n              this.numberOfStructures * part.realWidth) /\n            (this.numberOfStructures - 1);\n          left = index * (span + part.realWidth);\n        } else if (part.type === PartType.Runway) {\n          left = index * part.realWidth;\n        }\n      } else {\n        width = part.realHeight;\n        height = part.realDepth;\n      }\n\n      top += this.getRequiredRealOffsetY(partType, pname);\n      left += this.getRequiredRealOffsetX(partType, pname);\n\n      const scale = this.scale;\n\n      style.top = PADDING + top * scale + \"px\";\n      style.left = PADDING + left * scale + \"px\";\n      style.width = width * scale + \"px\";\n      style.height = height * scale + \"px\";\n      part.style = style;\n    },\n    applyJointStyleToPart(part, joint, pname) {\n      const style = part.style || {};\n      let top = 0,\n        left = 0;\n      if (pname === Perspective.Overlook) {\n        top = joint.realY;\n        left = joint.realX;\n      } else if (pname === Perspective.Side) {\n        top = joint.realZ;\n        left = joint.realX;\n      } else {\n        top = joint.realZ;\n        left = this.structure.realHeight - joint.realY - part.realHeight;\n      }\n\n      const scale = this.scale;\n      left *= scale;\n      top *= scale;\n\n      style.left = parseFloat(style.left) + left + \"px\";\n      style.top = parseFloat(style.top) + top + \"px\";\n\n      part.style = style;\n    },\n    generatePdf() {\n      this.$refs.html2Pdf.generatePdf();\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.form {\n  height: 80px;\n  display: flex;\n  align-items: center;\n  font-size: 14px;\n\n  span {\n    margin-left: 12px;\n    margin-right: 12px;\n    line-height: 24px;\n  }\n\n  input {\n    height: 24px;\n    margin-right: 12px;\n  }\n\n  button {\n    height: 24px;\n    margin-right: 12px;\n  }\n}\n\n.container {\n  width: 100%;\n  // border: 1px solid #ccc;\n\n  .perspective {\n    // border: 1px solid #ccc;\n    // margin: 15px;\n    display: inline-block;\n\n    .marker-container {\n      position: absolute;\n      width: 100%;\n      height: 100%;\n    }\n  }\n}\n</style>"]}]}